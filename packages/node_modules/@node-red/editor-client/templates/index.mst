<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>{{ page.title }}</title>
    <link rel="icon" type="image/png" href="{{{ page.favicon }}}">
    <link rel="mask-icon" href="{{{ page.tabicon.icon }}}" color="{{ page.tabicon.colour }}">
    <link rel="stylesheet" href="vendor/jquery/css/base/jquery-ui.min.css?v={{ cacheBuster }}">
    <link rel="stylesheet" href="vendor/font-awesome/css/font-awesome.min.css?v={{ cacheBuster }}">
    <link rel="stylesheet" href="red/style.min.css?v={{ cacheBuster }}">
    {{#page.css}}
    <link rel="stylesheet" href="{{.}}">
    {{/page.css}}
    {{#asset.vendorMonaco}}
    <link rel="stylesheet" href="vendor/monaco/style.css?v={{ cacheBuster }}">
    {{/asset.vendorMonaco}}
    <style>
  #main-header {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 40px;
    background-color: #8B0000; /* Color de fondo del header */
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 20px;
    z-index: 1000;
    box-sizing: border-box;
}

.header-buttons-left {
    display: flex;
    align-items: center;
}

.header-button {
    background-color: #f0f0f0; /* Nuevo color de fondo de los botones */
    color: #8B0000; /* Nuevo color de texto de los botones */
    border: none;
    padding: 5px 10px;
    cursor: pointer;
    white-space: nowrap;
    margin-right: 10px;
    border-radius: 4px; /* Borde redondeado */
}

.header-button:hover {
    background-color: #e0e0e0; /* Color de fondo de los botones al pasar el mouse */
}

#red-ui-editor {
    margin-top: 40px; /* Ajusta el margen superior para el contenido principal */
}

/* Estilo para la ventana emergente */
.popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8); /* Escalado inicial para animación */
    background-color: #fff;
    padding: 20px;
    border-radius: 10px; /* Bordes redondeados */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Sombra */
    z-index: 1000;
    max-width: 400px; /* Ancho máximo */
    width: 90%; /* Ancho responsivo */
    transition: transform 0.3s ease, opacity 0.3s ease; /* Transición suave */
    opacity: 0; /* Comienza invisible */
}

/* Mostrar el popup con la animación de escala */
.popup.show {
    transform: translate(-50%, -50%) scale(1); /* Escalado normal */
    opacity: 1; /* Visible */
}

/* Estilo del botón de cierre */
.popup-close {
    position: absolute;
    top: 10px;
    right: 10px;
    cursor: pointer;
    font-size: 20px;
    color: #888; /* Color gris para el botón de cierre */
    transition: color 0.3s ease; /* Transición de color */
}

.popup-close:hover {
    color: #333; /* Color más oscuro al pasar el mouse */
}

/* Estilo del título */
.popup h2 {
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 1.5em;
    color: #333;
    text-align: center; /* Centrar el título */
}

/* Estilo de la lista de flujos */
.list-group {
    list-style: none;
    padding: 0;
    margin: 0;
}

/* Estilo de cada elemento de la lista */
.list-group-item {
    padding: 10px 15px;
    margin-bottom: 10px;
    background-color: #f7f7f7; /* Fondo claro */
    border: 1px solid #ddd; /* Borde gris claro */
    border-radius: 5px; /* Bordes redondeados */
    transition: background-color 0.3s ease, box-shadow 0.3s ease; /* Transiciones */
}

/* Efecto hover en los elementos de la lista */
.list-group-item:hover {
    background-color: #e0e0e0; /* Cambio de color de fondo */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Sombra ligera al pasar el mouse */
}
    </style>
</head>
<body spellcheck="false">
<header id="main-header">
    <div class="header-buttons-left">
        <button id="my-button" class="header-button">Guardar flujos</button>
        <button id="load-button" class="header-button">Cargar flujos</button>
        <button id="classes-button" class="header-button" onclick="showClassList()">Mis Clases</button>
    </div>
    <button id="logout-button" class="header-button">Salir de Node-RED</button>
    <script src="vendor/jquery/js/jquery.min.js?v={{ cacheBuster }}"></script>
    <script src="vendor/jquery/js/jquery-ui.min.js?v={{ cacheBuster }}"></script>
</header>

<div id="red-ui-editor"></div>
<script src="vendor/vendor.js?v={{ cacheBuster }}"></script>
{{#asset.vendorMonaco}}
<script src="{{{ asset.vendorMonaco }}}?v={{ cacheBuster }}"></script>
{{/asset.vendorMonaco}}
<script src="{{{ asset.red }}}?v={{ cacheBuster }}"></script>
<script src="{{{ asset.main }}}?v={{ cacheBuster }}"></script>
{{# page.scripts }}
<script src="{{.}}"></script>
{{/page.scripts }}
{{#sessionMessages}}
<script>RED.sessionMessages = {{{sessionMessages}}};</script>
{{/sessionMessages}}

<script>

// Función para redirigir siempre a una URL específica
async function getOutNodeRed() {
    try {
        
        const redirectUrl = 'https://frontend-service-830425129942.europe-west1.run.app';
        
        // Redirige siempre a la URL especificada
        window.location.href = redirectUrl;
    } catch (error) {
        console.error('Error redirigiendo a la página:', error);
        throw error;
    }
}

// Función para detener el servicio de Node-RED
async function stopNodeRedService() {
    try {
        const jwtToken = await getJWTToken();
        const response = await fetch('https://backend-service-830425129942.europe-west1.run.app/stop-nodered', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${jwtToken}`
            }
        });
        if (response.status === 401) {
            alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.')
            throw new Error('El token ha expirado');
        }else if (response.ok) {
            return await response.json();
        } else {
            throw new Error('Error en la solicitud');
        }
    } catch (error) {
        console.error('Error al crear el flujo:', error);
        throw error;
    }
}

// Función para obtener las clases creadas por el usuario
async function getCreatedClasses(token) {
    try {
        const decodedToken = parseJwt(token);
        const response = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/user/createdclasses/${decodedToken.id}`, {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });
        if (response.status === 401) {
            alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.');
            throw new Error('El token ha expirado');
        } else if (!response.ok) {
            throw new Error('Network response was not ok');
        } else { 
            const data = await response.json();
            return data.data;
        }
    } catch (error) {
        console.error('Error obteniendo las clases creadas:', error);
        throw error;
    }
}

// Función para obtener las clases a las que se ha unido el usuario
async function getJoinedClasses(token) {
    try {
        const decodedToken = parseJwt(token);
        const response = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/user/joinedclasses/${decodedToken.id}`, {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });
        if (response.status === 401) {
            alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.');
            throw new Error('El token ha expirado');
        } else if (!response.ok) {
            throw new Error('Network response was not ok');
        } else {
            const data = await response.json();
            return data.data;
        }
    } catch (error) {
        console.error('Error obteniendo las clases a las que se ha unido:', error);
        throw error;
    }
}

// Función para abrir la ventana emergente con la lista de flujos
async function openFlowsWindow(flows) {
    const flowPopup = document.createElement('div');
    flowPopup.className = 'popup';

    const flowCloseButton = document.createElement('span');
    flowCloseButton.innerHTML = '&times;';
    flowCloseButton.className = 'popup-close';
    flowCloseButton.onclick = function() {
        flowPopup.classList.remove('show');
        setTimeout(() => document.body.removeChild(flowPopup), 300);
    };
    flowPopup.appendChild(flowCloseButton);

    const flowTitle = document.createElement('h2');
    flowTitle.textContent = 'Flujos de la Clase';
    flowPopup.appendChild(flowTitle);

    const flowList = document.createElement('ul');
    flowList.className = 'list-group';

    flows.forEach(function(flow) {
        const flowItem = document.createElement('li');
        flowItem.textContent = flow.name;
        flowItem.className = 'list-group-item';
        flowItem.style.cursor = 'pointer';

        flowItem.onclick = async function() {
            try {
                const token = await getJWTToken();
                const response = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/flow/${flow._id}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                if (response.status === 401) {
                    alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.');
                    throw new Error('El token ha expirado');
                } else if (!response.ok) {
                    throw new Error('Error al obtener los flujos');
                } else {
                    const flowData = await response.json();
                    const url = window.location.origin + window.location.pathname;
                    const postResponse = await fetch(`${url}flow/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            label: flowData.data.name,
                            nodes: JSON.parse(flowData.data.nodes).slice(1)
                        })
                    });

                    if (!postResponse.ok) {
                        throw new Error('Network response was not ok');
                    }

                    console.log('Flujo cargado exitosamente en Node-RED');
                }
            } catch (error) {
                console.error('Error al cargar el flujo:', error);
            }
        };

        flowList.appendChild(flowItem);
    });

    flowPopup.appendChild(flowList);
    document.body.appendChild(flowPopup);
    setTimeout(() => flowPopup.classList.add('show'), 10);
}

// Función para mostrar la lista de clases
async function showClassList() {
    try {
        const token = await getJWTToken();
        const role = await getRol(token);

        let classes;
        if (role === 'professor') {
            classes = await getCreatedClasses(token);
        } else if (role === 'student') {
            classes = await getJoinedClasses(token);
        } else {
            console.error('Role not recognized');
            throw new Error('El token ha expirado');
        }

        const popup = document.createElement('div');
        popup.className = 'popup';

        const closeButton = document.createElement('span');
        closeButton.innerHTML = '&times;';
        closeButton.className = 'popup-close';
        closeButton.onclick = function() {
            popup.classList.remove('show');
            setTimeout(() => document.body.removeChild(popup), 300);
        };
        popup.appendChild(closeButton);

        const title = document.createElement('h2');
        title.textContent = 'Mis Clases';
        popup.appendChild(title);

        const classList = document.createElement('ul');
        classList.id = 'classList';
        classList.className = 'list-group';

        classes.forEach(function(clase) {
            const listItem = document.createElement('li');
            listItem.textContent = clase.name; 
            listItem.className = 'list-group-item';
            listItem.style.cursor = 'pointer';
            
            listItem.onclick = async function() {
                try {
                    const flows = await getFlowsForClass(clase._id, token);
                    openFlowsWindow(flows.data);
                    
                } catch (error) {
                    console.error('Error al manejar el clic en la clase:', error);
                }
            };

            classList.appendChild(listItem);
        });

        popup.appendChild(classList);
        document.body.appendChild(popup);
        setTimeout(() => popup.classList.add('show'), 10);
    } catch (error) {
        console.error('Error al mostrar la lista de clases:', error);
    }
}

// Función para obtener los flujos de una clase específica
async function getFlowsForClass(classId, token) {
    const response = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/class/${classId}/flows`, {
        headers: {
            'Authorization': `Bearer ${token}`
        }
    });
    if (response.status === 401) {
        alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.');
        throw new Error('El token ha expirado');
    } else if (!response.ok) {
        throw new Error('Error al obtener los flujos');
    } else {
        const flows = await response.json();
        return flows;
    }
}


async function getRol(token) {
    try {
        // Decodificar el JWT para obtener el ID del usuario
        const decodedToken = parseJwt(token);
        if (!decodedToken || !decodedToken.id) {
            throw new Error('Token inválido o ID de usuario no encontrado.');
        }

        // Hacer una llamada al endpoint para obtener el rol del usuario
        const response = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/user/rol/${decodedToken.id}`, {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });
        if (response.status === 401) {
            alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.')
            throw new Error('El token ha expirado');
        }
        else if (!response.ok) {
            throw new Error('Network response was not ok');
        }else{
        const data = await response.json();
        return data.data.role;
        }
    } catch (error) {
        console.error('Error obteniendo el rol del usuario:', error);
        throw error;
    }
}

function parseJwt(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(window.atob(base64).split('').map(function(c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
                return JSON.parse(jsonPayload);
            } catch (error) {
                console.error('Error parsing JWT:', error);
                return null;
            }
        }

async function getJWTToken() {
    const url = window.location.origin + window.location.pathname
    const response = await fetch(`${url}jwtoken/`)
    const data = await response.json();
    return data.jwtToken;
}

async function showFlowListLoad() {
    try {
        // Obtén el token JWT
        const jwtToken = await getJWTToken();
        const decodedToken = parseJwt("Bearer " + jwtToken);

        // Realiza la solicitud para obtener los flujos
        const response = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/user/flows/${decodedToken.id}`, {
            headers: {
                'Authorization': `Bearer ${jwtToken}`
            }
        });
        if (response.status === 401) {
            alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.')
            throw new Error('El token ha expirado');
        }
        else if (!response.ok) {
            throw new Error('Network response was not ok');
        }else{

        const responseData = await response.json();
        const flows = responseData.data;
        console.log("Flows obtenidos:", flows);

        // Crear el popup
        const popup = document.createElement('div');
        popup.className = 'popup';

        const closeButton = document.createElement('span');
        closeButton.innerHTML = '&times;';
        closeButton.className = 'popup-close';
        closeButton.onclick = function() {
            document.body.removeChild(popup);
        };
        popup.appendChild(closeButton);

        const title = document.createElement('h2');
        title.textContent = 'Seleccionar flujo para cargar';
        popup.appendChild(title);

        const flowList = document.createElement('ul');
        flowList.id = 'flowList';
        flowList.className = 'list-group';

        flows.forEach(function(flow) {
            const listItem = document.createElement('li');
            listItem.textContent = flow.name;
            listItem.className = 'list-group-item';
            listItem.style.cursor = 'pointer';

            // Maneja el clic en un elemento de la lista
            listItem.onclick = async function() {
                try {
                    console.log("awqui:" + flow.nodes);
                    const url = window.location.origin + window.location.pathname;

                    // Realiza la solicitud POST para cargar el flujo
                    const response = await fetch(`${url}flow/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            label: flow.name,
                            nodes: JSON.parse(flow.nodes).slice(1)
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        if (response.status === 400 && errorText.includes("duplicate")) {
                            showMessage("El flujo de trabajo ya está cargado.");
                        } else {
                            throw new Error('Network response was not ok');
                        }
                    } else {
                        showMessage("El flujo de trabajo se ha cargado correctamente.");
                    }
                } catch (error) {
                    console.error('Error al cargar el flujo:', error);
                    showMessage("Error al cargar el flujo.");
                }
            };

            flowList.appendChild(listItem);
        });

        popup.appendChild(flowList);
        document.body.appendChild(popup);

        // Añadir la clase "show" para la animación
        setTimeout(() => {
            popup.classList.add('show');
        }, 10);  // Retraso para permitir que se renderice antes de la animación

        console.log("Popup creado:", popup);
        }
    } catch (error) {
        console.error('Error al mostrar la ventana emergente:', error);
    }
}

// Función para mostrar un mensaje en la pantalla
function showMessage(message) {
    // Crea el mensaje emergente
    const messagePopup = document.createElement('div');
    messagePopup.className = 'message-popup';
    messagePopup.textContent = message;

    // Añade el estilo para el mensaje emergente
    document.head.insertAdjacentHTML('beforeend', `
        <style>
            .message-popup {
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: #333;
                color: #fff;
                padding: 10px 20px;
                border-radius: 5px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
                z-index: 1001;
                opacity: 0;
                transition: opacity 0.3s ease-in-out;
            }

            .message-popup.show {
                opacity: 1;
            }
        </style>
    `);

    // Añade el mensaje al body
    document.body.appendChild(messagePopup);

    // Muestra el mensaje
    setTimeout(() => {
        messagePopup.classList.add('show');
    }, 0);

    // Oculta el mensaje después de un tiempo
    setTimeout(() => {
        messagePopup.classList.remove('show');
        setTimeout(() => {
            document.body.removeChild(messagePopup);
        }, 300); // Tiempo para la transición de ocultación
    }, 3000); // Tiempo visible del mensaje
}




// Manejar el evento beforeunload para detener el servicio de Node-RED
const handleBeforeUnload = (event) => {
    event.preventDefault();
    event.returnValue = '';
};

document.addEventListener('DOMContentLoaded', function() {
    const saveButton = document.getElementById('my-button');
    const loadButton = document.getElementById('load-button');
    const logoutButton = document.getElementById('logout-button');

    // Añadir el event listener para beforeunload
    window.addEventListener('beforeunload', handleBeforeUnload);

    saveButton.addEventListener('click', function() {
        showFlowList();
    });

    loadButton.addEventListener('click', function() {
        showFlowListLoad();
    });

    logoutButton.addEventListener('click', function() {
        getOutNodeRed();
    });
});
async function getFlows() {
    const url = window.location.origin + window.location.pathname
    const response = await fetch(`${url}flows/`);
    if (!response.ok) {
        throw new Error('Network response was not ok');
    }
    return await response.json();
}



function transformJson(flow) {
    const tab = {
        id: flow.id,
        type: "tab",
        label: flow.label,
        disabled: flow.disabled || false,
        info: flow.info || '',
        env: flow.env || []
    };
    // Elimina nodos duplicados tipo 'tab'
    const uniqueNodes = flow.nodes.filter(node => node.type !== 'tab');
    return JSON.stringify([tab, ...uniqueNodes]); // Convertir a cadena JSON
}

// Función para obtener los flujos con sus nodos
async function getFlowsWithNodes() {
    try {
        const url = window.location.origin + window.location.pathname
        const response = await fetch(`${url}flows/`);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        const nodes = await response.json();

        // Filtrar los nodos de tipo `tab` (los flujos)
        const flows = nodes.filter(node => node.type === 'tab');

        // Crear un objeto para almacenar los flujos con sus nodos, incluyendo el nodo `tab`
        const flowsWithNodes = flows.map(flow => {
            return {
                id: flow.id,
                label: flow.label,
                nodes: [flow, ...nodes.filter(node => node.z === flow.id)]
            };
        });

        // Mostrar los flujos con sus nodos
        console.log('Flows with Nodes:', flowsWithNodes);

        return flowsWithNodes;
    } catch (error) {
        console.error('Error fetching flows:', error);
    }
}

async function createNewFlow(datos) {
    try {
        const jwtToken = await getJWTToken();
        const response = await fetch('https://backend-service-830425129942.europe-west1.run.app/api/v1/flow/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${jwtToken}`
            },
            body: JSON.stringify(datos)
        });
        if (response.status === 401) {
            alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.')
            throw new Error('El token ha expirado');
        }
        else if (!response.ok) { 
            throw new Error('Error en la solicitud');
        } else {
            return await response.json();
        }
    } catch (error) {
        console.error('Error al crear el flujo:', error);
        throw error;
    }
}

async function getCustomFlows() {
    const jwtToken = await getJWTToken();
    const response = await fetch('https://backend-service-830425129942.europe-west1.run.app/api/v1/flow', {
        headers: {
            'Authorization': `Bearer ${jwtToken}`
        }
    });
    if (response.status === 401) {
        alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.')
        throw new Error('El token ha expirado');
    }
    else if (!response.ok) {
        throw new Error('Network response was not ok');
    }else{
    return await response.json();
    }
}

// Función para mostrar la lista de flujos en una ventana emergente
async function showFlowList() {
    try {
        const flows = await getFlowsWithNodes();

        const popup = document.createElement('div');
        popup.className = 'popup';

        const closeButton = document.createElement('span');
        closeButton.innerHTML = '&times;';
        closeButton.className = 'popup-close';
        closeButton.onclick = function() {
            popup.classList.remove('show'); // Inicia la animación de cierre
            setTimeout(() => document.body.removeChild(popup), 300); // Elimina el popup después de la animación
        };
        popup.appendChild(closeButton);

        const title = document.createElement('h2');
        title.textContent = 'Selecciona el flujo que quieras guardar en la base de datos';
        popup.appendChild(title);

        const flowList = document.createElement('ul');
        flowList.id = 'flowList';
        flowList.className = 'list-group';

        // Agregar elementos a la lista de flujos según los datos obtenidos del backend
        flows.forEach(function(flow) {
            const listItem = document.createElement('li');
            listItem.textContent = flow.label;
            listItem.className = 'list-group-item';
            listItem.style.cursor = 'pointer';

            listItem.onclick = async function() {
                try {
                    const transformedJson = transformJson(flow);
                    console.log('Transformed JSON:', transformedJson);

                    const datosNuevoRecurso = {
                        name: flow.label,
                        nodes: transformedJson
                    };

                    const result = await createNewFlow(datosNuevoRecurso);
                    console.log('Nuevo flujo creado:', result);

                    // Mostrar un mensaje de confirmación
                    showMessage("El flujo se ha guardado correctamente.");
                } catch (error) {
                    console.error('Error al obtener el flujo:', error);
                    showMessage("Error al guardar el flujo.");
                }
            };

            flowList.appendChild(listItem);
        });

        popup.appendChild(flowList);
        document.body.appendChild(popup);

        // Añade la clase para mostrar el popup con animación
        setTimeout(() => popup.classList.add('show'), 10);
    } catch (error) {
        console.error('Error al mostrar la ventana emergente:', error);
    }
}

// Función para mostrar un mensaje en la pantalla
function showMessage(message) {
    // Crea el mensaje emergente
    const messagePopup = document.createElement('div');
    messagePopup.className = 'message-popup';
    messagePopup.textContent = message;

    // Añade el estilo para el mensaje emergente
    document.head.insertAdjacentHTML('beforeend', `
        <style>
            .message-popup {
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: #333;
                color: #fff;
                padding: 10px 20px;
                border-radius: 5px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
                z-index: 1001;
                opacity: 0;
                transition: opacity 0.3s ease-in-out;
            }

            .message-popup.show {
                opacity: 1;
            }
        </style>
    `);

    // Añade el mensaje al body
    document.body.appendChild(messagePopup);

    // Muestra el mensaje
    setTimeout(() => {
        messagePopup.classList.add('show');
    }, 0);

    // Oculta el mensaje después de un tiempo
    setTimeout(() => {
        messagePopup.classList.remove('show');
        setTimeout(() => {
            document.body.removeChild(messagePopup);
        }, 300); // Tiempo para la transición de ocultación
    }, 3000); // Tiempo visible del mensaje
}

</script>
</body>
</html>
