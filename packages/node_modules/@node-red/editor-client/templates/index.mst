<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>{{ page.title }}</title>
    <link rel="icon" type="image/png" href="{{{ page.favicon }}}">
    <link rel="mask-icon" href="{{{ page.tabicon.icon }}}" color="{{ page.tabicon.colour }}">
    <link rel="stylesheet" href="vendor/jquery/css/base/jquery-ui.min.css?v={{ cacheBuster }}">
    <link rel="stylesheet" href="vendor/font-awesome/css/font-awesome.min.css?v={{ cacheBuster }}">
    <link rel="stylesheet" href="red/style.min.css?v={{ cacheBuster }}">
    {{#page.css}}
    <link rel="stylesheet" href="{{.}}">
    {{/page.css}}
    {{#asset.vendorMonaco}}
    <link rel="stylesheet" href="vendor/monaco/style.css?v={{ cacheBuster }}">
    {{/asset.vendorMonaco}}
    <style>
  #main-header {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 40px;
    background-color: #8B0000; /* Color de fondo del header */
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 20px;
    z-index: 1000;
    box-sizing: border-box;
}

.header-buttons-left {
    display: flex;
    align-items: center;
}

.header-button {
    background-color: #f0f0f0; /* Nuevo color de fondo de los botones */
    color: #8B0000; /* Nuevo color de texto de los botones */
    border: none;
    padding: 5px 10px;
    cursor: pointer;
    white-space: nowrap;
    margin-right: 10px;
    border-radius: 4px; /* Borde redondeado */
}

.header-button:hover {
    background-color: #e0e0e0; /* Color de fondo de los botones al pasar el mouse */
}

#red-ui-editor {
    margin-top: 40px; /* Ajusta el margen superior para el contenido principal */
}

/* Estilos para el contenedor del modal */
.popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 80%;
    max-width: 600px;
    background-color: #fff;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    overflow: hidden; /* Oculta cualquier contenido que se desborde del contenedor */
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.popup.show {
    opacity: 1;
}

/* Estilos para el contenido del modal */
.popup-content {
    padding: 20px;
    max-height: 400px; /* Ajusta la altura máxima del área con scroll */
    overflow-y: auto; /* Habilita el scroll vertical si el contenido es mayor que max-height */
}

/* Estilos para el botón de cerrar */
.popup-close {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 24px;
    cursor: pointer;
}

/* Estilos para la lista de flujos */
.list-group {
    list-style-type: none;
    padding: 0;
    margin: 0;
}

/* Estilos para los elementos de la lista */
.list-group-item {
    padding: 10px;
    border-bottom: 1px solid #ddd;
}

.spinner-container {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 255, 255, 0.8);
    padding: 20px;
    border-radius: 5px;
    z-index: 999; /* Asegúrate de que esté por encima del contenido */
}


/* Estilo de cada elemento de la lista */
.list-group-item {
    padding: 10px 15px;
    margin-bottom: 10px;
    background-color: #f7f7f7; /* Fondo claro */
    border: 1px solid #ddd; /* Borde gris claro */
    border-radius: 5px; /* Bordes redondeados */
    transition: background-color 0.3s ease, box-shadow 0.3s ease; /* Transiciones */
}

/* Efecto hover en los elementos de la lista */
.list-group-item:hover {
    background-color: #e0e0e0; /* Cambio de color de fondo */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Sombra ligera al pasar el mouse */
}
    </style>
</head>
<body spellcheck="false">
<header id="main-header">
    <div class="header-buttons-left">
        <button id="my-button" class="header-button">Guardar flujos</button>
        <button id="load-button" class="header-button">Cargar flujos</button>
        <button id="classes-button" class="header-button" onclick="showClassList()">Mis Clases</button>
    </div>
    <button id="logout-button" class="header-button">Salir de Node-RED</button>
    <script src="vendor/jquery/js/jquery.min.js?v={{ cacheBuster }}"></script>
    <script src="vendor/jquery/js/jquery-ui.min.js?v={{ cacheBuster }}"></script>

    
</header>

<div id="red-ui-editor"></div>
<script src="vendor/vendor.js?v={{ cacheBuster }}"></script>
{{#asset.vendorMonaco}}
<script src="{{{ asset.vendorMonaco }}}?v={{ cacheBuster }}"></script>
{{/asset.vendorMonaco}}
<script src="{{{ asset.red }}}?v={{ cacheBuster }}"></script>
<script src="{{{ asset.main }}}?v={{ cacheBuster }}"></script>
{{# page.scripts }}
<script src="{{.}}"></script>
{{/page.scripts }}
{{#sessionMessages}}
<script>RED.sessionMessages = {{{sessionMessages}}};</script>
{{/sessionMessages}}

<script>

// Función para redirigir siempre a una URL específica
async function getOutNodeRed() {
    try {
        
        const redirectUrl = 'https://multi-node-red-830425129942.europe-west1.run.app';
        
        // Redirige siempre a la URL especificada
        window.location.href = redirectUrl;
    } catch (error) {
        console.error('Error redirigiendo a la página:', error);
        throw error;
    }
}

// Función para detener el servicio de Node-RED
// Función para detener el servicio de Node-RED
async function stopNodeRedService() {
    try {
        const jwtToken = await getJWTToken();
        const response = await fetch('https://backend-service-830425129942.europe-west1.run.app/api/v1/node/stop-nodered', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${jwtToken}`
            }
        });
        if (response.status === 401) {
            alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.');
            throw new Error('El token ha expirado');
        } else if (response.ok) {
            return await response.json();
        } else {
            throw new Error('Error en la solicitud');
        }
    } catch (error) {
        console.error('Error al detener el servicio de Node-RED:', error);
        throw error;
    }
}

// Función para obtener las clases creadas por el usuario
async function getCreatedClasses(token) {
    try {
        const decodedToken = parseJwt(token);
        const response = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/user/createdclasses/${decodedToken.id}`, {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });
        if (response.status === 401) {
            alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.');
            throw new Error('El token ha expirado');
        } else if (!response.ok) {
            throw new Error('Network response was not ok');
        } else { 
            const data = await response.json();
            return data.data;
        }
    } catch (error) {
        console.error('Error obteniendo las clases creadas:', error);
        throw error;
    }
}

// Función para obtener las clases a las que se ha unido el usuario
async function getJoinedClasses(token) {
    try {
        const decodedToken = parseJwt(token);
        const response = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/user/joinedclasses/${decodedToken.id}`, {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });
        if (response.status === 401) {
            alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.');
            throw new Error('El token ha expirado');
        } else if (!response.ok) {
            throw new Error('Network response was not ok');
        } else {
            const data = await response.json();
            return data.data;
        }
    } catch (error) {
        console.error('Error obteniendo las clases a las que se ha unido:', error);
        throw error;
    }
}


// Función para abrir la ventana emergente con la lista de flujos
async function openFlowsWindow(flows) {
    const flowPopup = document.createElement('div');
    flowPopup.className = 'popup';

    const flowCloseButton = document.createElement('span');
    flowCloseButton.innerHTML = '&times;';
    flowCloseButton.className = 'popup-close';
    flowCloseButton.onclick = function() {
        flowPopup.classList.remove('show');
        setTimeout(() => document.body.removeChild(flowPopup), 300);
    };
    flowPopup.appendChild(flowCloseButton);

    const flowTitle = document.createElement('h2');
    flowTitle.textContent = 'Flujos de la Clase';
    flowTitle.style.textAlign = 'center'; // Centrar el título
    flowPopup.appendChild(flowTitle);

    const flowList = document.createElement('ul');
    flowList.className = 'list-group';

    // Aplicar scroll al contenedor de la lista
    flowList.style.maxHeight = '400px'; // Limitar la altura máxima para que aparezca el scroll
    flowList.style.overflowY = 'auto'; // Habilitar el scroll vertical

    for (const flow of flows) {
        try {
            // Obtener el nombre del usuario propietario del flujo
            const token = await getJWTToken();
            const userResponse = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/flow/user/${flow._id}`, {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (!userResponse.ok) {
                throw new Error('Error al obtener el propietario del flujo');
            }

            const userData = await userResponse.json();
            const userName = userData.data.name || 'Desconocido';

            // Crear el elemento de la lista con el nombre del flujo y el nombre del usuario
            const flowItem = document.createElement('li');
            flowItem.textContent = `${flow.name} - ${userName}`;
            flowItem.className = 'list-group-item';
            flowItem.style.cursor = 'pointer';

            flowItem.onclick = async function() {
                try {
                    const response = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/flow/${flow._id}`, {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (response.status === 401) {
                        alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.');
                        throw new Error('El token ha expirado');
                    } else if (!response.ok) {
                        throw new Error('Error al obtener los flujos');
                    } else {
                        const flowData = await response.json();
                        const url = window.location.origin + window.location.pathname;
                        const postResponse = await fetch(`${url}flow/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                label: flowData.data.name,
                                nodes: JSON.parse(flowData.data.nodes).slice(1)
                            })
                        });

                        if (!postResponse.ok) {
                            const errorText = await postResponse.text();
                            if (postResponse.status === 400 && errorText.includes("duplicate")) {
                                alert("El flujo ya está cargado en Node-RED. Si no puedes verlo, pulsa el botón 'Actualizar flujos' que se encuentra arriba a la derecha e inténtalo de nuevo");
                            } else {
                                alert("Error al cargar el flujo. Por favor, intenta de nuevo.");
                            }
                        } else {
                            console.log('Flujo cargado exitosamente en Node-RED');
                        }
                    }
                } catch (error) {
                    console.error('Error al cargar el flujo:', error);
                    alert("Error al cargar el flujo. Por favor, intenta de nuevo.");
                } finally {
                    // Cerrar el modal después de seleccionar un flujo
                    flowPopup.classList.remove('show');
                    setTimeout(() => document.body.removeChild(flowPopup), 300);
                }
            };

            flowList.appendChild(flowItem);
        } catch (error) {
            console.error('Error al obtener el propietario del flujo:', error);
            alert("Error al obtener el propietario del flujo. Por favor, intenta de nuevo.");
        }
    }

    flowPopup.appendChild(flowList);
    document.body.appendChild(flowPopup);
    setTimeout(() => flowPopup.classList.add('show'), 10);
}



// Función para cerrar el popup
async function closePopup(popup) {
    return new Promise((resolve) => {
        popup.classList.remove('show'); // Ocultar el popup
        setTimeout(() => {
            document.body.removeChild(popup); // Eliminar el popup del DOM
            resolve();
        }, 300); // Tiempo de transición para ocultar el popup
    });
}

// Función para cerrar el popup
async function closePopup(popup) {
    return new Promise((resolve) => {
        // Asegúrate de que el modal esté visible antes de intentar ocultarlo
        if (popup.classList.contains('show')) {
            popup.classList.remove('show'); // Ocultar el popup
            setTimeout(() => {
                document.body.removeChild(popup); // Eliminar el popup del DOM
                resolve();
            }, 300); // Tiempo de transición para ocultar el popup
        } else {
            resolve(); // Resolver la promesa si el popup ya está oculto
        }
    });
}

// Función para mostrar la lista de clases
// Función para mostrar la lista de clases
async function showClassList() {
    try {
        const token = await getJWTToken();
        const role = await getRol(token);

        let classes;
        if (role === 'professor') {
            classes = await getCreatedClasses(token);
        } else if (role === 'student') {
            classes = await getJoinedClasses(token);
        } else {
            console.error('Role not recognized');
            throw new Error('El token ha expirado');
        }

        // Crear el popup de clases
        const popup = document.createElement('div');
        popup.className = 'popup';

        const closeButton = document.createElement('span');
        closeButton.innerHTML = '&times;';
        closeButton.className = 'popup-close';
        closeButton.onclick = async function() {
            // Cerrar el modal de clases sin esperar a que el spinner se oculte
            await closePopup(popup);
        };
        popup.appendChild(closeButton);

        const title = document.createElement('h2');
        title.textContent = 'Mis Clases';
        title.style.textAlign = 'center'; // Centrar el título
        popup.appendChild(title);

        const classList = document.createElement('ul');
        classList.id = 'classList';
        classList.className = 'list-group';
        classList.style.maxHeight = '400px'; // Establecer la altura máxima del contenedor
        classList.style.overflowY = 'auto'; // Añadir desplazamiento vertical si es necesario

        classes.forEach(function(clase) {
            const listItem = document.createElement('li');
            listItem.textContent = clase.name;
            listItem.className = 'list-group-item';
            listItem.style.cursor = 'pointer';
            
            listItem.onclick = async function() {
                // Crear y mostrar el spinner de carga
                const loadingContainer = document.createElement('div');
                loadingContainer.style.position = 'fixed';
                loadingContainer.style.top = '50%';
                loadingContainer.style.left = '50%';
                loadingContainer.style.transform = 'translate(-50%, -50%)';
                loadingContainer.style.textAlign = 'center';
                loadingContainer.style.zIndex = '1000';
                loadingContainer.className = 'loading-container'; // Añadir una clase para fácil eliminación

                const spinner = document.createElement('div');
                spinner.className = 'spinner';
                spinner.style.border = '4px solid rgba(0, 0, 0, 0.1)';
                spinner.style.borderTop = '4px solid #333';
                spinner.style.borderRadius = '50%';
                spinner.style.width = '40px';
                spinner.style.height = '40px';
                spinner.style.animation = 'spin 1s linear infinite';
                spinner.style.margin = '0 auto';

                const loadingMessage = document.createElement('p');
                loadingMessage.textContent = 'Cargando...';
                loadingMessage.style.fontFamily = 'Arial, sans-serif';
                loadingMessage.style.fontSize = '16px';
                loadingMessage.style.color = '#333';
                loadingMessage.style.marginTop = '10px';

                loadingContainer.appendChild(spinner);
                loadingContainer.appendChild(loadingMessage);
                document.body.appendChild(loadingContainer);

                // Temporizador para ocultar el spinner después de 5 segundos
                const spinnerTimeout = setTimeout(() => {
                    loadingContainer.style.display = 'none';
                    setTimeout(() => {
                        if (loadingContainer) {
                            document.body.removeChild(loadingContainer);
                        }
                    }, 300); // Tiempo para la transición de ocultación
                }, 7000); // 5 segundos

                try {
                    // Cerrar el modal de clases
                    await closePopup(popup);

                    // Obtener los flujos para la clase seleccionada
                    const flows = await getFlowsForClass(clase._id, token);

                    // Mostrar el modal de flujos
                    openFlowsWindow(flows.data);
                } catch (error) {
                    console.error('Error al manejar el clic en la clase:', error);
                } finally {
                    // Asegurarse de que el spinner se oculte después de 5 segundos
                    // No cancelar el temporizador
                }
            };

            classList.appendChild(listItem);
        });

        popup.appendChild(classList);
        document.body.appendChild(popup);
        setTimeout(() => popup.classList.add('show'), 10);
    } catch (error) {
        console.error('Error al mostrar la lista de clases:', error);
    }
}


// Función para obtener los flujos de una clase específica
async function getFlowsForClass(classId, token) {
    const response = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/class/${classId}/flows`, {
        headers: {
            'Authorization': `Bearer ${token}`
        }
    });
    if (response.status === 401) {
        alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.');
        throw new Error('El token ha expirado');
    } else if (!response.ok) {
        throw new Error('Error al obtener los flujos');
    } else {
        const flows = await response.json();
        return flows;
    }
}


async function getRol(token) {
    try {
        // Decodificar el JWT para obtener el ID del usuario
        const decodedToken = parseJwt(token);
        if (!decodedToken || !decodedToken.id) {
            throw new Error('Token inválido o ID de usuario no encontrado.');
        }

        // Hacer una llamada al endpoint para obtener el rol del usuario
        const response = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/user/rol/${decodedToken.id}`, {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });
        if (response.status === 401) {
            alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.')
            throw new Error('El token ha expirado');
        }
        else if (!response.ok) {
            throw new Error('Network response was not ok');
        }else{
        const data = await response.json();
        return data.data.role;
        }
    } catch (error) {
        console.error('Error obteniendo el rol del usuario:', error);
        throw error;
    }
}

function parseJwt(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(window.atob(base64).split('').map(function(c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
                return JSON.parse(jsonPayload);
            } catch (error) {
                console.error('Error parsing JWT:', error);
                return null;
            }
        }

async function getJWTToken() {
    const url = window.location.origin + window.location.pathname
    const response = await fetch(`${url}jwtoken/`)
    const data = await response.json();
    return data.jwtToken;
}

async function showFlowListLoad() {
    try {
        // Obtén el token JWT
        const jwtToken = await getJWTToken();
        const decodedToken = parseJwt("Bearer " + jwtToken);

        // Realiza la solicitud para obtener los flujos
        const response = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/user/flows/${decodedToken.id}`, {
            headers: {
                'Authorization': `Bearer ${jwtToken}`
            }
        });

        if (response.status === 401) {
            alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.');
            throw new Error('El token ha expirado');
        } else if (!response.ok) {
            throw new Error('Network response was not ok');
        } else {
            const responseData = await response.json();
            const flows = responseData.data;
            console.log("Flows obtenidos:", flows);

            // Crear el popup
            const popup = document.createElement('div');
            popup.className = 'popup';

            const closeButton = document.createElement('span');
            closeButton.innerHTML = '&times;';
            closeButton.className = 'popup-close';
            closeButton.onclick = function() {
                document.body.removeChild(popup);
            };
            popup.appendChild(closeButton);

            const title = document.createElement('h2');
            title.textContent = '¿Qué flujo quieres abrir?';
            title.style.textAlign = 'center';  // Centra el texto
            title.style.margin = '0';          // Elimina márgenes predeterminados
            title.style.padding = '10px';      
            popup.appendChild(title);

            // Contenedor del contenido desplazable
            const contentContainer = document.createElement('div');
            contentContainer.className = 'popup-content';

            const flowList = document.createElement('ul');
            flowList.id = 'flowList';
            flowList.className = 'list-group';

            flows.forEach(function(flow) {
                const listItem = document.createElement('li');
                listItem.textContent = flow.name;
                listItem.className = 'list-group-item';
                listItem.style.cursor = 'pointer';

                // Maneja el clic en un elemento de la lista
                listItem.onclick = async function() {
                    try {
                        const url = window.location.origin + window.location.pathname;

                        // Realiza la solicitud POST para cargar el flujo
                        const response = await fetch(`${url}flow/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                label: flow.name,
                                nodes: JSON.parse(flow.nodes).slice(1)
                            })
                        });

                        if (!response.ok) {
                            const errorText = await response.text();
                            if (response.status === 400 && errorText.includes("duplicate")) {
                                alert("El flujo ya está cargado en Node-RED. Si no puedes verlo, pulsa el botón 'Actualizar flujos' que se encuentra arriba a la derecha e inténtalo de nuevo");
                            } else {
                                alert("Error al cargar el flujo. Por favor, intenta de nuevo.");
                            }
                        }
                    } catch (error) {
                        console.error('Error al cargar el flujo:', error);
                        alert("Error al cargar el flujo. Por favor, intenta de nuevo.");
                    } finally {
                        // Cierra el modal después de la operación
                        document.body.removeChild(popup);
                    }
                };

                flowList.appendChild(listItem);
            });

            contentContainer.appendChild(flowList);
            popup.appendChild(contentContainer);
            document.body.appendChild(popup);

            // Añadir la clase "show" para la animación
            setTimeout(() => {
                popup.classList.add('show');
            }, 10);  // Retraso para permitir que se renderice antes de la animación

            console.log("Popup creado:", popup);
        }
    } catch (error) {
        console.error('Error al mostrar la ventana emergente:', error);
    }
}





// Función para mostrar un mensaje en la pantalla
function showMessage(message) {
    // Crea el mensaje emergente
    const messagePopup = document.createElement('div');
    messagePopup.className = 'message-popup';
    messagePopup.textContent = message;

    // Añade el estilo para el mensaje emergente
    document.head.insertAdjacentHTML('beforeend', `
        <style>
            .message-popup {
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: #333;
                color: #fff;
                padding: 10px 20px;
                border-radius: 5px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
                z-index: 1001;
                opacity: 0;
                transition: opacity 0.3s ease-in-out;
            }

            .message-popup.show {
                opacity: 1;
            }
        </style>
    `);

    // Añade el mensaje al body
    document.body.appendChild(messagePopup);

    // Muestra el mensaje
    setTimeout(() => {
        messagePopup.classList.add('show');
    }, 0);

    // Oculta el mensaje después de un tiempo
    setTimeout(() => {
        messagePopup.classList.remove('show');
        setTimeout(() => {
            document.body.removeChild(messagePopup);
        }, 300); // Tiempo para la transición de ocultación
    }, 3000); // Tiempo visible del mensaje
}




// Manejar el evento beforeunload para advertir al usuario
const handleBeforeUnload = (event) => {
    // Prevenir que el usuario abandone la página sin advertencia
    event.preventDefault();
    event.returnValue = ''; // Necesario para que algunos navegadores muestren el cuadro de diálogo predeterminado
};




document.addEventListener('DOMContentLoaded', function() {
    const saveButton = document.getElementById('my-button');
    const loadButton = document.getElementById('load-button');
    const logoutButton = document.getElementById('logout-button');
    const classesButton = document.getElementById('classes-button');

    // Añadir el event listener para beforeunload
    window.addEventListener('beforeunload', function (event) {
        if (logoutClicked) {
            // No mostrar el mensaje de confirmación si se hizo clic en logout
            return;
        }

        // Personaliza el mensaje para los navegadores que lo permiten
        const message = '¿Estás seguro de que quieres salir? Los cambios no guardados se perderán.';
        
        // Configura el mensaje que será mostrado al usuario
        event.returnValue = message; // Estándar para la mayoría de los navegadores
        return message; // Para navegadores más antiguos
    });

    saveButton.addEventListener('click', function() {
        // Crear y mostrar el spinner mientras se carga el modal
        const spinnerContainer = document.createElement('div');
        spinnerContainer.className = 'spinner-container';

        const spinner = document.createElement('div');
        spinner.className = 'spinner';
        spinner.style.border = '4px solid rgba(0, 0, 0, 0.1)';
        spinner.style.borderTop = '4px solid #333';
        spinner.style.borderRadius = '50%';
        spinner.style.width = '40px';
        spinner.style.height = '40px';
        spinner.style.animation = 'spin 1s linear infinite';
        spinner.style.margin = '0 auto';

        spinnerContainer.appendChild(spinner);
        document.body.appendChild(spinnerContainer);

        // Llamar a showFlowList y pasar una función de callback
        showFlowList().finally(() => {
            // Eliminar el spinner después de que el modal se muestre
            document.body.removeChild(spinnerContainer);
        });
    });

loadButton.addEventListener('click', function() {
    // Crear y mostrar el spinner mientras se carga el modal
    const spinnerContainer = document.createElement('div');
    spinnerContainer.className = 'spinner-container';

    const spinner = document.createElement('div');
    spinner.className = 'spinner';
    spinner.style.border = '4px solid rgba(0, 0, 0, 0.1)';
    spinner.style.borderTop = '4px solid #333';
    spinner.style.borderRadius = '50%';
    spinner.style.width = '40px';
    spinner.style.height = '40px';
    spinner.style.animation = 'spin 1s linear infinite';
    spinner.style.margin = '0 auto';

    spinnerContainer.appendChild(spinner);
    document.body.appendChild(spinnerContainer);

    // Llamar a showFlowListLoad y pasar una función de callback
    showFlowListLoad().finally(() => {
        // Eliminar el spinner después de que el modal se muestre
        document.body.removeChild(spinnerContainer);
    });
});

    logoutButton.addEventListener('click', async function() {
        // Activar la bandera para evitar la confirmación al salir
        logoutClicked = true;

        // Crear y mostrar el spinner mientras se realiza el POST
        const spinnerContainer = document.createElement('div');
        spinnerContainer.className = 'spinner-container';

        const spinner = document.createElement('div');
        spinner.className = 'spinner';
        spinner.style.border = '4px solid rgba(0, 0, 0, 0.1)';
        spinner.style.borderTop = '4px solid #333';
        spinner.style.borderRadius = '50%';
        spinner.style.width = '40px';
        spinner.style.height = '40px';
        spinner.style.animation = 'spin 1s linear infinite';
        spinner.style.margin = '0 auto';

        spinnerContainer.appendChild(spinner);
        document.body.appendChild(spinnerContainer);

        try {
            // Realizar el POST al endpoint
            const jwtToken = await getJWTToken();
            const response = await fetch('https://backend-service-830425129942.europe-west1.run.app/api/v1/node/stop-nodered', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${jwtToken}`
                }
            });

            if (!response.ok) {
                throw new Error('Error al detener Node-RED');
            }

            // Redirigir después de que el POST se complete
            window.location.href = 'https://multi-node-red-830425129942.europe-west1.run.app';
        } catch (error) {
            console.error('Error al realizar el logout:', error);
        } finally {
            // Eliminar el spinner después de que se haya hecho el POST y la redirección haya comenzado
            document.body.removeChild(spinnerContainer);
        }
    });

        classesButton.addEventListener('click', function() {
        // Crear y mostrar el spinner mientras se carga el modal
        const spinnerContainer = document.createElement('div');
        spinnerContainer.className = 'spinner-container';

        const spinner = document.createElement('div');
        spinner.className = 'spinner';
        spinner.style.border = '4px solid rgba(0, 0, 0, 0.1)';
        spinner.style.borderTop = '4px solid #333';
        spinner.style.borderRadius = '50%';
        spinner.style.width = '40px';
        spinner.style.height = '40px';
        spinner.style.animation = 'spin 1s linear infinite';
        spinner.style.margin = '0 auto';

        spinnerContainer.appendChild(spinner);
        document.body.appendChild(spinnerContainer);

        // Llamar a showClassList y eliminar el spinner después de que el modal se muestre
        showClassList().finally(() => {
            document.body.removeChild(spinnerContainer);
        });
    });
});
async function getFlows() {
    const url = window.location.origin + window.location.pathname
    const response = await fetch(`${url}flows/`);
    if (!response.ok) {
        throw new Error('Network response was not ok');
    }
    return await response.json();
}



function transformJson(flow) {
    const tab = {
        id: flow.id,
        type: "tab",
        label: flow.label,
        disabled: flow.disabled || false,
        info: flow.info || '',
        env: flow.env || []
    };
    // Elimina nodos duplicados tipo 'tab'
    const uniqueNodes = flow.nodes.filter(node => node.type !== 'tab');
    return JSON.stringify([tab, ...uniqueNodes]); // Convertir a cadena JSON
}

// Función para obtener los flujos con sus nodos
async function getFlowsWithNodes() {
    try {
        const url = window.location.origin + window.location.pathname
        const response = await fetch(`${url}flows/`);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        const nodes = await response.json();

        // Filtrar los nodos de tipo `tab` (los flujos)
        const flows = nodes.filter(node => node.type === 'tab');

        // Crear un objeto para almacenar los flujos con sus nodos, incluyendo el nodo `tab`
        const flowsWithNodes = flows.map(flow => {
            return {
                id: flow.id,
                label: flow.label,
                nodes: [flow, ...nodes.filter(node => node.z === flow.id)]
            };
        });

        // Mostrar los flujos con sus nodos
        console.log('Flows with Nodes:', flowsWithNodes);

        return flowsWithNodes;
    } catch (error) {
        console.error('Error fetching flows:', error);
    }
}

async function createNewFlow(datos) {
    try {
        const jwtToken = await getJWTToken();
        const response = await fetch('https://backend-service-830425129942.europe-west1.run.app/api/v1/flow/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${jwtToken}`
            },
            body: JSON.stringify(datos)
        });
        if (response.status === 401) {
            alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.')
            throw new Error('El token ha expirado');
        }
        else if (!response.ok) { 
            throw new Error('Error en la solicitud');
        } else {
            return await response.json();
        }
    } catch (error) {
        console.error('Error al crear el flujo:', error);
        throw error;
    }
}

async function getCustomFlows() {
    const jwtToken = await getJWTToken();
    const response = await fetch('https://backend-service-830425129942.europe-west1.run.app/api/v1/flow', {
        headers: {
            'Authorization': `Bearer ${jwtToken}`
        }
    });
    if (response.status === 401) {
        alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.')
        throw new Error('El token ha expirado');
    }
    else if (!response.ok) {
        throw new Error('Network response was not ok');
    }else{
    return await response.json();
    }
}

async function showFlowList() {
    try {
        // Obtener los flujos guardados desde el servidor
        const jwtToken = await getJWTToken();
        const decodedToken = parseJwt("Bearer " + jwtToken);

        const response = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/user/flows/${decodedToken.id}`, {
            headers: {
                'Authorization': `Bearer ${jwtToken}`
            }
        });

        if (response.status === 401) {
            alert('Tu sesión ha expirado. Por favor, inicia sesión de nuevo.');
            throw new Error('El token ha expirado');
        } else if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        const responseData = await response.json();
        const savedFlows = responseData.data;
        console.log("Flows obtenidos:", savedFlows);

        const flows = await getFlowsWithNodes();

        const popup = document.createElement('div');
        popup.className = 'popup';

        const closeButton = document.createElement('span');
        closeButton.innerHTML = '&times;';
        closeButton.className = 'popup-close';
        closeButton.onclick = function() {
            popup.classList.remove('show');
            setTimeout(() => document.body.removeChild(popup), 300);
        };
        popup.appendChild(closeButton);

        const title = document.createElement('h2');
        title.textContent = 'Selecciona el flujo que quieras guardar en la base de datos';
        popup.appendChild(title);

        // Contenedor de contenido del modal con scroll
        const contentContainer = document.createElement('div');
        contentContainer.className = 'popup-content';

        const flowList = document.createElement('ul');
        flowList.id = 'flowList';
        flowList.className = 'list-group';

        // Crear el contenedor del spinner y el mensaje
        const loadingContainer = document.createElement('div');
        loadingContainer.style.display = 'none'; // Oculto inicialmente
        loadingContainer.style.textAlign = 'center';
        loadingContainer.style.marginTop = '20px';

        // Crear el spinner
        const spinner = document.createElement('div');
        spinner.className = 'spinner';
        spinner.style.border = '4px solid rgba(0, 0, 0, 0.1)';
        spinner.style.borderTop = '4px solid #333';
        spinner.style.borderRadius = '50%';
        spinner.style.width = '40px';
        spinner.style.height = '40px';
        spinner.style.animation = 'spin 1s linear infinite';
        spinner.style.margin = '0 auto';

        // Crear el mensaje de "Guardando..."
        const savingMessage = document.createElement('p');
        savingMessage.textContent = 'Guardando...';
        savingMessage.style.fontFamily = 'Arial, sans-serif';
        savingMessage.style.fontSize = '16px';
        savingMessage.style.color = '#333';
        savingMessage.style.marginTop = '10px';

        // Agregar spinner y mensaje al contenedor
        loadingContainer.appendChild(spinner);
        loadingContainer.appendChild(savingMessage);
        popup.appendChild(loadingContainer);

        flows.forEach(function(flow) {
            const listItem = document.createElement('li');
            listItem.textContent = flow.label;
            listItem.className = 'list-group-item';
            listItem.style.cursor = 'pointer';

            // Verificar si el flujo ya está guardado
            const savedFlow = savedFlows.find(savedFlow => savedFlow.name === flow.label);
            const isSaved = !!savedFlow;

            if (isSaved) {
                listItem.textContent += ' (Ya guardado)';
                listItem.onclick = function() {
                    // Mostrar mensaje de confirmación para sobrescribir
                    showConfirmationDialog(
                        'Este flujo ya está guardado. ¿Desea sobrescribirlo?',
                        async function() {
                            // Aceptar sobrescribir
                            // Mostrar el spinner y el mensaje
                            loadingContainer.style.display = 'block';
                            try {
                                await updateFlow(savedFlow._id, flow);
                                // Cerrar el modal después de actualizar
                                popup.classList.remove('show');
                                setTimeout(() => document.body.removeChild(popup), 300);
                                
                                // Mostrar el mensaje de éxito después de cerrar el modal
                                showMessage("El flujo se ha actualizado correctamente.");
                            } catch (error) {
                                console.error('Error al actualizar el flujo:', error);
                                showMessage("Error al actualizar el flujo.");
                            } finally {
                                // Ocultar el spinner y el mensaje
                                loadingContainer.style.display = 'none';
                            }
                        },
                        function() {
                            // Cancelar sobrescribir
                            console.log('Sobrescribir cancelado');
                        }
                    );
                };
            } else {
                listItem.onclick = async function() {
                    // Deshabilitar todos los flujos para evitar que se haga clic en ellos mientras se guarda
                    disableFlows(true);

                    // Mostrar el spinner y el mensaje
                    loadingContainer.style.display = 'block';

                    try {
                        await saveFlow(flow);
                        // Cerrar el modal después de guardar
                        popup.classList.remove('show');
                        setTimeout(() => document.body.removeChild(popup), 300);
                        
                        // Mostrar el mensaje de éxito después de cerrar el modal
                        showMessage("El flujo se ha guardado correctamente.");
                    } catch (error) {
                        console.error('Error al obtener el flujo:', error);
                        showMessage("Error al guardar el flujo.");
                    } finally {
                        // Ocultar el spinner y el mensaje
                        loadingContainer.style.display = 'none';
                        // Habilitar los flujos nuevamente
                        disableFlows(false);
                    }
                };
            }

            flowList.appendChild(listItem);
        });

        contentContainer.appendChild(flowList);
        popup.appendChild(contentContainer);
        document.body.appendChild(popup);

        setTimeout(() => popup.classList.add('show'), 10);

        // Función para habilitar o deshabilitar los flujos
        function disableFlows(disable) {
            const items = flowList.querySelectorAll('li');
            items.forEach(item => {
                item.style.pointerEvents = disable ? 'none' : 'auto';
                item.style.opacity = disable ? '0.5' : '1';
            });
        }

        async function saveFlow(flow) {
            const transformedJson = transformJson(flow);
            const datosNuevoRecurso = {
                name: flow.label,
                nodes: transformedJson
            };

            const result = await createNewFlow(datosNuevoRecurso);
            console.log('Nuevo flujo creado:', result);
        }

        async function updateFlow(flowId, flow) {
            const transformedJson = transformJson(flow);
            const datosActualizarRecurso = {
                nodes: transformedJson
            };

            const jwtToken = await getJWTToken();
            try {
                const response = await fetch(`https://backend-service-830425129942.europe-west1.run.app/api/v1/flow/${flowId}`, {
                    method: 'PATCH',  // Cambiado de PUT a PATCH
                    headers: {
                        'Authorization': `Bearer ${jwtToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(datosActualizarRecurso)
                });

                if (!response.ok) {
                    // Leer el cuerpo de la respuesta para obtener más detalles sobre el error
                    const errorData = await response.json();
                    throw new Error(`Error: ${response.status} - ${errorData.message}`);
                }

                const result = await response.json();
                console.log('Flujo actualizado:', result);
            } catch (error) {
                console.error('Error al actualizar el flujo:', error);
                throw error; // Lanza el error para que sea capturado en el bloque finally
            }
        }

        function closeModal() {
            popup.classList.remove('show');
            setTimeout(() => document.body.removeChild(popup), 300);
        }

        function showMessage(message) {
            // Crear un contenedor para el mensaje
            const messageContainer = document.createElement('div');
            messageContainer.className = 'message-container';
            messageContainer.style.position = 'fixed';
            messageContainer.style.top = '50%';
            messageContainer.style.left = '50%';
            messageContainer.style.transform = 'translate(-50%, -50%)'; // Centrar vertical y horizontalmente
            messageContainer.style.padding = '20px';
            messageContainer.style.backgroundColor = '#333';
            messageContainer.style.color = '#fff';
            messageContainer.style.borderRadius = '5px';
            messageContainer.style.zIndex = '1000';
            messageContainer.style.textAlign = 'center';
            messageContainer.style.fontFamily = 'Arial, sans-serif';
            messageContainer.style.fontSize = '16px';

            messageContainer.textContent = message;

            document.body.appendChild(messageContainer);

            // Ocultar el mensaje después de 2 segundos
            setTimeout(() => {
                messageContainer.style.opacity = '0';
                setTimeout(() => document.body.removeChild(messageContainer), 300); // Esperar 300ms para la transición
            }, 2000);
        }

    } catch (error) {
        console.error('Error al mostrar la ventana emergente:', error);
    }
}




// Función para mostrar un mensaje de confirmación
function showConfirmationDialog(message, onConfirm, onCancel) {
    // Crear el mensaje emergente
    const confirmationPopup = document.createElement('div');
    confirmationPopup.className = 'confirmation-popup';

    const popupContent = document.createElement('div');
    popupContent.className = 'confirmation-content';

    const messageElement = document.createElement('p');
    messageElement.textContent = message;

    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'confirmation-buttons';

    const confirmButton = document.createElement('button');
    confirmButton.textContent = 'Aceptar';
    confirmButton.onclick = function() {
        onConfirm();
        closePopup();
    };

    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancelar';
    cancelButton.onclick = function() {
        onCancel();
        closePopup();
    };

    buttonContainer.appendChild(confirmButton);
    buttonContainer.appendChild(cancelButton);
    popupContent.appendChild(messageElement);
    popupContent.appendChild(buttonContainer);
    confirmationPopup.appendChild(popupContent);
    document.body.appendChild(confirmationPopup);

    function closePopup() {
        confirmationPopup.classList.remove('show');
        setTimeout(() => document.body.removeChild(confirmationPopup), 300);
    }

    setTimeout(() => confirmationPopup.classList.add('show'), 10);
}

// Añadir el estilo para el spinner (animación) y el mensaje de confirmación
document.head.insertAdjacentHTML('beforeend', `
    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .confirmation-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            padding: 20px;
        }

        .confirmation-popup.show {
            opacity: 1;
        }

        .confirmation-content {
            text-align: center;
        }

        .confirmation-buttons {
            margin-top: 20px;
        }

        .confirmation-buttons button {
            margin: 0 10px;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        .confirmation-buttons button:first-of-type {
            background-color: #007bff;
            color: #fff;
        }

        .confirmation-buttons button:last-of-type {
            background-color: #6c757d;
            color: #fff;
        }
    </style>
`);


// Función para mostrar un mensaje en la pantalla
function showMessage(message) {
    // Crea el mensaje emergente
    const messagePopup = document.createElement('div');
    messagePopup.className = 'message-popup';
    messagePopup.textContent = message;

    // Añade el mensaje al body
    document.body.appendChild(messagePopup);

    // Muestra el mensaje
    setTimeout(() => {
        messagePopup.classList.add('show');
    }, 0);

    // Oculta el mensaje después de un tiempo
    setTimeout(() => {
        messagePopup.classList.remove('show');
        setTimeout(() => {
            document.body.removeChild(messagePopup);
        }, 300); // Tiempo para la transición de ocultación
    }, 3000); // Tiempo visible del mensaje
}

</script>
</body>
</html>
