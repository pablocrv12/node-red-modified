<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>{{ page.title }}</title>
    <link rel="icon" type="image/png" href="{{{ page.favicon }}}">
    <link rel="mask-icon" href="{{{ page.tabicon.icon }}}" color="{{ page.tabicon.colour }}">
    <link rel="stylesheet" href="vendor/jquery/css/base/jquery-ui.min.css?v={{ cacheBuster }}">
    <link rel="stylesheet" href="vendor/font-awesome/css/font-awesome.min.css?v={{ cacheBuster }}">
    <link rel="stylesheet" href="red/style.min.css?v={{ cacheBuster }}">
    {{#page.css}}
    <link rel="stylesheet" href="{{.}}">
    {{/page.css}}
    {{#asset.vendorMonaco}}
    <link rel="stylesheet" href="vendor/monaco/style.css?v={{ cacheBuster }}">
    {{/asset.vendorMonaco}}
    <style>
        #main-header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background-color: #8B0000; /* Color de fondo del header */
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1000;
            box-sizing: border-box;
        }

        .header-buttons-left {
            display: flex;
            align-items: center;
        }

        .header-button {
            background-color: #f0f0f0; /* Nuevo color de fondo de los botones */
            color: #8B0000; /* Nuevo color de texto de los botones */
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            white-space: nowrap;
            margin-right: 10px;
            border-radius: 4px; /* Borde redondeado */
        }

        .header-button:hover {
            background-color: #e0e0e0; /* Color de fondo de los botones al pasar el mouse */
        }

        #red-ui-editor {
            margin-top: 40px; /* Ajusta el margen superior para el contenido principal */
        }

        .popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        .popup-close {
            position: absolute;
            top: 5px;
            right: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body spellcheck="false">
<header id="main-header">
    <div class="header-buttons-left">
        <button id="my-button" class="header-button">Guardar flujos</button>
        <button id="load-button" class="header-button">Cargar flujos</button>
        <button id="classes-button" class="header-button" onclick="showClassList()">Mis Clases</button>
    </div>
    <button id="logout-button" class="header-button">Salir de Node-RED</button>
    <script src="vendor/jquery/js/jquery.min.js?v={{ cacheBuster }}"></script>
    <script src="vendor/jquery/js/jquery-ui.min.js?v={{ cacheBuster }}"></script>
</header>

<div id="red-ui-editor"></div>
<script src="vendor/vendor.js?v={{ cacheBuster }}"></script>
{{#asset.vendorMonaco}}
<script src="{{{ asset.vendorMonaco }}}?v={{ cacheBuster }}"></script>
{{/asset.vendorMonaco}}
<script src="{{{ asset.red }}}?v={{ cacheBuster }}"></script>
<script src="{{{ asset.main }}}?v={{ cacheBuster }}"></script>
{{# page.scripts }}
<script src="{{.}}"></script>
{{/page.scripts }}
{{#sessionMessages}}
<script>RED.sessionMessages = {{{sessionMessages}}};</script>
{{/sessionMessages}}

<script>

// Función para redirigir siempre a una URL específica
async function getOutNodeRed() {
    try {
        const redirectUrl = 'https://frontend-service-3flglcef2q-ew.a.run.app';
        
        // Redirige siempre a la URL especificada
        window.location.href = redirectUrl;
    } catch (error) {
        console.error('Error redirigiendo a la página:', error);
        throw error;
    }
}


// Función para obtener las clases creadas por el usuario
async function getCreatedClasses(token) {
    try {
        const decodedToken = parseJwt(token);

        const response = await fetch(`https://backend-service-3flglcef2q-ew.a.run.app/api/v1/user/createdclasses/${decodedToken.id}`, {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const data = await response.json();
        return data.data;
    } catch (error) {
        console.error('Error obteniendo las clases creadas:', error);
        throw error;
    }
}

// Función para obtener las clases a las que se ha unido el usuario
async function getJoinedClasses(token) {
    try {
        const decodedToken = parseJwt(token);

        const response = await fetch(`https://backend-service-3flglcef2q-ew.a.run.app/api/v1/user/joinedclasses/${decodedToken.id}`, {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const data = await response.json();
        return data.data;
    } catch (error) {
        console.error('Error obteniendo las clases a las que se ha unido:', error);
        throw error;
    }
}


    async function openFlowsWindow(flows) {
    const flowPopup = document.createElement('div');
    flowPopup.className = 'popup';

    const flowCloseButton = document.createElement('span');
    flowCloseButton.innerHTML = '&times;';
    flowCloseButton.className = 'popup-close';
    flowCloseButton.onclick = function() {
        document.body.removeChild(flowPopup);
    };
    flowPopup.appendChild(flowCloseButton);

    const flowTitle = document.createElement('h2');
    flowTitle.textContent = 'Flujos de la Clase';
    flowPopup.appendChild(flowTitle);

    const flowList = document.createElement('ul');
    flowList.className = 'list-group';

    flows.forEach(function(flow) {
        const flowItem = document.createElement('li');
        flowItem.textContent = flow.name;
        flowItem.className = 'list-group-item';
        flowItem.style.cursor = 'pointer';

        flowItem.onclick = async function() {
            try {
                const token = await getJWTToken();
                // Realizamos la solicitud GET para obtener el flujo
                const response = await fetch(`https://backend-service-3flglcef2q-ew.a.run.app/api/v1/flow/${flow._id}`, {
                    headers: {
                    'Authorization': `Bearer ${token}`
                        }
                    });

                if (!response.ok) {
                    throw new Error('Error al obtener los flujos');
                    }

                // Convertimos la respuesta a JSON
                const flowData = await response.json();
                // Luego hacemos la solicitud POST para cargar el flujo en Node-RED
                const url = window.location.origin + window.location.pathname
                const postResponse = await fetch(`${url}flow/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        label: flowData.data.name,
                        nodes: JSON.parse(flowData.data.nodes).slice(1)
                    })
                });

                if (!postResponse.ok) {
                    throw new Error('Network response was not ok');
                }

                console.log('Flujo cargado exitosamente en Node-RED');
            } catch (error) {
                console.error('Error al cargar el flujo:', error);
            }
        };

        flowList.appendChild(flowItem);
    });

    flowPopup.appendChild(flowList);
    document.body.appendChild(flowPopup);
}

        async function showClassList() {
            try {
                const token = await getJWTToken();
                const role = await getRol(token);

                let classes;
                if (role === 'professor') {
                    classes = await getCreatedClasses(token);
                } else if (role === 'student') {
                    classes = await getJoinedClasses(token);
                } else {
                    console.error('Role not recognized');
                    return;
                }

                const popup = document.createElement('div');
                popup.className = 'popup';

                const closeButton = document.createElement('span');
                closeButton.innerHTML = '&times;';
                closeButton.className = 'popup-close';
                closeButton.onclick = function() {
                    document.body.removeChild(popup);
                };
                popup.appendChild(closeButton);

                const title = document.createElement('h2');
                title.textContent = 'Mis Clases';
                popup.appendChild(title);

                const classList = document.createElement('ul');
                classList.id = 'classList';
                classList.className = 'list-group';

                classes.forEach(function(clase) {
                    const listItem = document.createElement('li');
                    listItem.textContent = clase.name; 
                    listItem.className = 'list-group-item';
                    listItem.style.cursor = 'pointer';
                    
                    listItem.onclick = async function() {
                        try {
                            const flows = await getFlowsForClass(clase._id, token);
                            openFlowsWindow(flows.data);
                            
                        } catch (error) {
                            console.error('Error al manejar el clic en la clase:', error);
                        }
                    };

                    classList.appendChild(listItem);
                });

                popup.appendChild(classList);
                document.body.appendChild(popup);
            } catch (error) {
                console.error('Error al mostrar la lista de clases:', error);
            }
        }

// Función para obtener los flujos de una clase específica
async function getFlowsForClass(classId, token) {
    const response = await fetch(`https://backend-service-3flglcef2q-ew.a.run.app/api/v1/class/${classId}/flows`, {
        headers: {
            'Authorization': `Bearer ${token}`
        }
    });

    if (!response.ok) {
        throw new Error('Error al obtener los flujos');
    }

    const flows = await response.json();
    return flows;
}


async function getRol(token) {
    try {
        // Decodificar el JWT para obtener el ID del usuario
        const decodedToken = parseJwt(token);
        if (!decodedToken || !decodedToken.id) {
            throw new Error('Token inválido o ID de usuario no encontrado.');
        }

        // Hacer una llamada al endpoint para obtener el rol del usuario
        const response = await fetch(`https://backend-service-3flglcef2q-ew.a.run.app/api/v1/user/rol/${decodedToken.id}`, {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });

        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        const data = await response.json();
        return data.data.role;
    } catch (error) {
        console.error('Error obteniendo el rol del usuario:', error);
        throw error;
    }
}

function parseJwt(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(window.atob(base64).split('').map(function(c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
                return JSON.parse(jsonPayload);
            } catch (error) {
                console.error('Error parsing JWT:', error);
                return null;
            }
        }

async function getJWTToken() {
    const url = window.location.origin + window.location.pathname
    const response = await fetch(`${url}jwtoken/`)
    const data = await response.json();
    return data.jwtToken;
}

async function showFlowListLoad() {
    try {
        const jwtToken = await getJWTToken();
        const decodedToken = parseJwt("Bearer "+ jwtToken);
        console.log(decodedToken.id);
        const response = await fetch(`https://backend-service-3flglcef2q-ew.a.run.app/api/v1/user/flows/${decodedToken.id}`, {
            headers: {
                'Authorization': `Bearer ${jwtToken}`
            }
        });
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const responseData = await response.json();
        const flows = responseData.data; 
        
        const popup = document.createElement('div');
        popup.className = 'popup';

        const closeButton = document.createElement('span');
        closeButton.innerHTML = '&times;';
        closeButton.className = 'popup-close';
        closeButton.onclick = function() {
            document.body.removeChild(popup);
        };
        popup.appendChild(closeButton);

        const title = document.createElement('h2');
        title.textContent = 'Seleccionar flujo para cargar';
        popup.appendChild(title);

        const flowList = document.createElement('ul');
        flowList.id = 'flowList';
        flowList.className = 'list-group';
        
        flows.forEach(function(flow) {
            const listItem = document.createElement('li');
            listItem.textContent = flow.name; 
            listItem.className = 'list-group-item';
            listItem.style.cursor = 'pointer';
            
            listItem.onclick = async function() {
                try {
                    console.log("awqui:" + flow.nodes)
                    const flowId = flow.id;
                    const url = window.location.origin + window.location.pathname
                    const response = await fetch(`${url}flow/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            label: flow.name,
                            nodes: JSON.parse(flow.nodes).slice(1)
                        })
                    });
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                } catch (error) {
                    console.error('Error al cargar el flujo:', error);
                }
            };
            
            flowList.appendChild(listItem);
        });
        
        popup.appendChild(flowList);
        document.body.appendChild(popup);
    } catch (error) {
        console.error('Error al mostrar la ventana emergente:', error);
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const saveButton = document.getElementById('my-button');
    const loadButton = document.getElementById('load-button');
    const logoutButton = document.getElementById('logout-button');

    saveButton.addEventListener('click', function() {
        showFlowList();
    });

    loadButton.addEventListener('click', function() {
        showFlowListLoad();
    });

    // Asignar la función getOutNodeRed al botón de salir
    logoutButton.addEventListener('click', getOutNodeRed);
});

async function getFlows() {
    const url = window.location.origin + window.location.pathname
    const response = await fetch(`${url}flows/`);
    if (!response.ok) {
        throw new Error('Network response was not ok');
    }
    return await response.json();
}



function transformJson(flow) {
    const tab = {
        id: flow.id,
        type: "tab",
        label: flow.label,
        disabled: flow.disabled || false,
        info: flow.info || '',
        env: flow.env || []
    };
    // Elimina nodos duplicados tipo 'tab'
    const uniqueNodes = flow.nodes.filter(node => node.type !== 'tab');
    return JSON.stringify([tab, ...uniqueNodes]); // Convertir a cadena JSON
}

// Función para obtener los flujos con sus nodos
async function getFlowsWithNodes() {
    try {
        const url = window.location.origin + window.location.pathname
        const response = await fetch(`${url}flows/`);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        const nodes = await response.json();

        // Filtrar los nodos de tipo `tab` (los flujos)
        const flows = nodes.filter(node => node.type === 'tab');

        // Crear un objeto para almacenar los flujos con sus nodos, incluyendo el nodo `tab`
        const flowsWithNodes = flows.map(flow => {
            return {
                id: flow.id,
                label: flow.label,
                nodes: [flow, ...nodes.filter(node => node.z === flow.id)]
            };
        });

        // Mostrar los flujos con sus nodos
        console.log('Flows with Nodes:', flowsWithNodes);

        return flowsWithNodes;
    } catch (error) {
        console.error('Error fetching flows:', error);
    }
}

async function createNewFlow(datos) {
    try {
        const jwtToken = await getJWTToken();
        const response = await fetch('https://backend-service-3flglcef2q-ew.a.run.app/api/v1/flow/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${jwtToken}`
            },
            body: JSON.stringify(datos)
        });
        if (response.ok) {
            return await response.json();
        } else {
            throw new Error('Error en la solicitud');
        }
    } catch (error) {
        console.error('Error al crear el flujo:', error);
        throw error;
    }
}

async function getCustomFlows() {
    const jwtToken = await getJWTToken();
    const response = await fetch('https://backend-service-3flglcef2q-ew.a.run.app/api/v1/flow', {
        headers: {
            'Authorization': `Bearer ${jwtToken}`
        }
    });
    if (!response.ok) {
        throw new Error('Network response was not ok');
    }
    return await response.json();
}

// Función para mostrar la lista de flujos en una ventana emergente
async function showFlowList() {
    try {
        const flows = await getFlowsWithNodes();

        const popup = document.createElement('div');
        popup.className = 'popup';

        const closeButton = document.createElement('span');
        closeButton.innerHTML = '&times;';
        closeButton.className = 'popup-close';
        closeButton.onclick = function() {
            document.body.removeChild(popup);
        };
        popup.appendChild(closeButton);

        const title = document.createElement('h2');
        title.textContent = 'Seleccionar flujo';
        popup.appendChild(title);

        const flowList = document.createElement('ul');
        flowList.id = 'flowList';
        flowList.className = 'list-group';

        // Agregar elementos a la lista de flujos según los datos obtenidos del backend
        flows.forEach(function(flow) {
            const listItem = document.createElement('li');
            listItem.textContent = flow.label; // Acceder al nombre de cada flow
            listItem.className = 'list-group-item';
            listItem.style.cursor = 'pointer';

            listItem.onclick = async function() {
                try {
                    const transformedJson = transformJson(flow);
                    console.log('Transformed JSON:', transformedJson); // Añadir depuración

                    // Crear los datos del nuevo recurso
                    const datosNuevoRecurso = {
                        name: flow.label,  // Usar flow.label para el nombre
                        nodes: transformedJson  // Directamente usar la cadena JSON
                    };

                    // Enviar los datos del nuevo recurso al backend
                    const result = await createNewFlow(datosNuevoRecurso);
                    console.log('Nuevo flujo creado:', result);
                } catch (error) {
                    console.error('Error al obtener el flujo:', error);
                }
            };

            flowList.appendChild(listItem);
        });

        popup.appendChild(flowList);
        document.body.appendChild(popup);
    } catch (error) {
        console.error('Error al mostrar la ventana emergente:', error);
    }
}
</script>
</body>
</html>
